/****************************************************************************/
/*                                                                          */
/*                         GRAPHICS LIBRARY                                 */
/*                                                                          */
/*     PROGRAMER : TUDI                                                     */
/*                                                                          */
/*     FULL NAME : JOZSA BODNAR ISTVAN                                      */
/*                                                                          */
/*     PLEASE IF YOU FIND BETER ALGORITMS CONTACT ME AT                     */
/*                                                                          */
/*              tudi@freemail.deltanet.ro                                   */
/*                                                                          */
/*     This library contains useful stuff for game programers.I was         */
/*     more on speed.If you add somthing please sand to me a copy to        */
/*                                                                          */
/****************************************************************************/

#include <graphics.h>
#include <math.h>
#include <fcntl.h>
#include <io.h>
#include <alloc.h>

#define msin(fok) sin(fok*0.017453292)
#define mcos(fok) cos(fok*0.017453292)
#define sqr(mit) (mit*mit)

#define maxX 319
#define maxY 200

char far *vgascreen=(char *)0xA0000000;
unsigned int potsize=64000;
char far *potscreen=(char *)0xA0000000;
unsigned char pal[255][3];
//float sintbl[360];

int huge detectSVGA();
void setgr();
void initpot();
void putpixel2(int,int,unsigned char);
unsigned char getpixel2(int,int);
void copypottoscreen();
void clearpot(unsigned char);

void setpal(unsigned char,unsigned char,unsigned char,unsigned char);/*paleta atalitas*/
void getpal(unsigned char,unsigned char*,unsigned char*,unsigned char*);/*paleta ertek lebontas*/
char readgpipal(unsigned char *,unsigned char,unsigned char,unsigned char);/*a gpi paletaja kulon paleta file */
void writegpipal(unsigned char *);/*fileba menti a paletat*/
unsigned char* loadgpi(unsigned char *,unsigned char);/*ez egy error miatt kell(paletta) mely szerint hozza kell adni egy erteket*/
void sdda(int,int,int,int,unsigned char *,int);/*lassu memoriabol vonalhuzo algoritmus*/
void sfill(int,int,int,int,int,int,int,int,unsigned char *);/*lassu texturazo algoritmus*/
void szscircle(int,int,float,float,unsigned char *);/*lassu kor alaku texturazas elforditva*/
void szselipse(int,int,float,float,float,unsigned char *);/*lassu elipszis texturazas elforditva*/
void sline(signed int,signed int,signed int,signed int,unsigned char far*,unsigned char);/*gyors memoriabol vonalhuzo algoritmus*/
void orveny(int,int,float,float);/* orveny efektus*/
void line2(signed int,signed int,signed int,signed int,unsigned char);/*gyors vonalhuzo algoritmus*/
void fatline(signed int,signed int,signed int,signed int,unsigned char);/*gyors szeles vonalhuzo algoritmus*/
void tputpixel(int,int);/*transzparens pixel kirakasa*/
void tline(signed int,signed int,signed int,signed int);/*gyors atlatszo vonalhuzo algoritmus*/
void tline2(signed int,signed int,signed int,signed int);/*gyors atlatszo vonalhuzo algoritmus*/
void inittransparent(signed char,signed char,signed char);/*a transparens reszek milyen szinkonfiguracioval terjenek el*/
void fadepixel(unsigned char,signed char);/*egy pixelt besotit/kivilagosit egy bizonyos ertekkel*/
void savepal();/*lementi a paletat*/
void loadpal();/*loadolja a paletat*/
void htline(int,int,int);/*gyors vizszintes atlatszo vonal egyes fuggvenyeknek inkabb*/
void tcircle(int,int,float);/*atlatszo kor */
void telipse(int,int,float,float,float);/*atlatszo elipszis forgatva*/
void ftcircle(int,int,float);/*kitoltott atlatszo kor*/
void ftelipse(int,int,float,float,float);/*!!SZAR!! elforgatott atlatszo elipszis kitoltve */
void tfill(int,int,int,int,int,int,int,int);/*fill atlatszo valtozata*/
void fill(int,int,int,int,int,int,int,int,unsigned char *);/*sfill jobb valtozata texturazo algoritmus*/
void putgpi(int,int,unsigned char far *);/*gyors gpi kirako agoritmus*/
void putpic(unsigned char far *,int,int,unsigned char,unsigned char,unsigned char);/*NOT FOR PUBLIC a memeoriabol egy reszt kirak akarcsak a putgpi de itt te a dod meg a kep adatait*/
void safeputgpi(int,int,unsigned char far *);/*megnezi kilog-e a gpi a kepernyorol ha igen akkor onan levagja*/
void hsline(int,int,int,unsigned char far *,unsigned char);/*gyors vizszintes vonalhuzo algoritmus(texture) surit/tagit*/
void fitgpi(int,int,int,int,unsigned char far*);/*egy teglalapba belegyomoszoli az adott teturat*/
void circle2(int,int,int,unsigned char);/*szimpla korrajzolo algoritmus*/
void hline(int,int,int,unsigned char);/*szinpla gyors vizszintes vonal algoritmus*/
void fcircle2(int,int,int,unsigned char);/*szimpla kitoltott kor*/
void szelipse(int,int,int,int,float,unsigned char);/*elipszis elforgatva*/
void fszelipse(int,int,int,int,float,unsigned char);/*kitoltott elforgatot elipszis*/
void onlysline(signed int,signed int,signed int,signed int,unsigned char far*,int,unsigned char);/*a texturabol csak ott rak pixelt ahol megegyezik a megadottal*/
void onlyfill(int,int,int,int,int,int,int,int,unsigned char *,unsigned char);/*a texturabol csak ott rak pixelt ahol megegyezik a megadottal*/
void nsline(signed int,signed int,signed int,signed int,unsigned char far*,int,unsigned char);/*a megadott pixelt nem rakja ki*/
void nfill(int,int,int,int,int,int,int,int,unsigned char *,unsigned char);/*a megadott pixelt nem rakja ki*/
void savegpi(int,int,unsigned char,unsigned char,unsigned char *);/*fileba menti az adott kepet(nem garantalt*/
unsigned char far * savepic(int,int,unsigned char,unsigned char);/*a kepernyorol lementi egy gpi-be a kepet*/
void bar2(int,int,int,int,unsigned char);/*kitoltott teglalap*/
void nputpic(unsigned char far *,int,int,unsigned char,unsigned char,unsigned char,unsigned char);/*NOT FOR PUBLIC a memeoriabol egy reszt kirak akarcsak a putgpi de itt te adod meg a kep adatait*/
void nsafeputgpi(int x,int y,unsigned char far *source,unsigned char);/*kiszur egy bizonyos szint a gpibol*/
void onlyputpic(unsigned char far *,int,int,unsigned char,unsigned char,unsigned char,unsigned char);/*NOT FOR PUBLIC a memeoriabol egy reszt kirak akarcsak a putgpi de itt te adod meg a kep adatait*/
void onlysafeputgpi(int x,int y,unsigned char far *source,unsigned char);/*a gpi-bol csak bizonyos szint rak ki*/
void nfitgpi(int x1o,int y1o,int x2o,int y2o,unsigned char far *source,unsigned char);/*belegyomoszoli a negyzetbe a gpi-t szint nem rak ki*/
void nhsline(int x1,int x2,int y,unsigned char far *source,unsigned char h,unsigned char noc);/*belegyomoszoli a vonalba a memoriat szint nem rak ki*/
void onlyfitgpi(int x1o,int y1o,int x2o,int y2o,unsigned char far *source,unsigned char);/*belegyomoszoli a negyzetbe a gpi-t szint nem rak ki*/
void onlyhsline(int x1,int x2,int y,unsigned char far *source,unsigned char h,unsigned char noc);/*belegyomoszoli a vonalba a memoriat szint nem rak ki*/
void szgpi(int,int,int,int,int,int,int,int,unsigned char *,float);/*texturazo algoritmus,bugs?*/
void scircle(int,int,int,unsigned char far *);/*gyors kortexturazas*/
void selipse(int,int,int,int,unsigned char far *);/*gyors elipszislitolto*/
void tbar(int,int,int,int);/*kitoltott attetszo teglalap*/

void setgr()
	{
	 int errorcode;
	 int gdriver, gmode;
	 gdriver = installuserdriver("SVGA256", detectSVGA);
	 gdriver = DETECT;
	 initgraph(&gdriver, &gmode, "");
	}

int huge detectSVGA()
 {
	int driver, mode,
	sugmode=0;
	detectgraph(&driver, &mode);
	if ((driver == EGA) || (driver == VGA))return sugmode;
	 else return grError;
}

void getpal(unsigned char color,unsigned char *red,unsigned char *green,unsigned char *blue)
 {
	unsigned char r,g,b;
	asm {
	 mov dx,0x3C7
	 mov al,color
	 out dx,al
	 add dx,2
	 in al,dx
	 mov [r],al
	 in al,dx
	 mov [g],al
	 in al,dx
	 mov [b],al
	}
	 *red=r;
	 *green=g;
	 *blue=b;
 }


void setpal(unsigned char c,unsigned char r,unsigned char g,unsigned char b)
 {asm {
	mov dx,3c8h
	mov al,[c]
	out dx,al
	inc dx
	mov al,[r]
	out dx,al
	mov al,[g]
	out dx,al
	mov al,[b]
	out dx,al
	}
 }

 unsigned char *loadgpi(unsigned char *nev,unsigned char plusz)
	{
	 unsigned char sx,sy,i,j;
	 unsigned char *source;
	 int file=open(nev,O_RDONLY);
	 if(file==-1)return(NULL);
	 lseek(file,0,SEEK_SET);
	 _read(file,&sx,1);
	 _read(file,&sy,1);
	 source=(unsigned char *)malloc(sx*sy+2);
	 if(source==NULL)
		{
		 close(file);
		 return(NULL);
		}
	 *source=sx;
	 *(source+1)=sy;
	for(i=0;i<sy;i++)
	 for(j=0;j<sx;j++)
		{
		 _read(file,source+i*sx+j+2,1);
			*(source+i*sx+j+2)+=plusz;
		}
	 close(file);
	 return(source);
	}

 char readgpipal(unsigned char *nev,unsigned char honnan,unsigned char meddig,unsigned char hova)
	{
	 unsigned char r,g,b,counter=hova,i;
	 int file=open(nev,O_RDONLY);
	 if(file==-1)return(0);
	 for (i=0;i<255;i++)
		{
		 _read(file,&r,1);
		 _read(file,&g,1);
		 _read(file,&b,1);
		 if(i>=honnan && i<=meddig)
			{
			 setpal(counter,r,g,b);
			 counter++;
			}
		}
	 close(file);
	 return(1);
	}

void writegpipal(unsigned char *nev)
 {
	unsigned char r,g,b;
	int i,file=open(nev,O_TRUNC | O_CREAT | O_WRONLY | O_DENYNONE);
	if(file==-1)return;
	for (i=0;i<=255;i++)
	 {
		getpal(i,&r,&g,&b);
		_write(file,&r,1);
		_write(file,&g,1);
		_write(file,&b,1);
	 }
	close(file);
 }

void sdda(int x1,int y1,int x2,int y2,unsigned char *source,int nrx)
 {
	float dx,dy,xi,yi,x,y,c=0,ci;
	int s,k;
	dx=x2-x1;
	dy=y2-y1;
	if(abs(dx)>abs(dy))s=abs(dx);
	 else s=abs(dy);
	xi=dx/s;
	yi=dy/s;
	ci=(float)nrx/s;
	putpixel2(x=x1,y=y1,*(source));
	for(k=0;k<s;k++,x+=xi,y+=yi,c+=ci)
	 putpixel2(x,y,*(source+(int)(c)));
 }

void sfill(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,unsigned char *source)
 {
	float dx1,dy1,xi1,yi1,x_1,y_1,dx2,dy2,xi2,yi2,x_2,y_2,dx,dy,xi,yi,x,y,osz,oszi,sori,sor;
	int s,s1,s2,k,k1,t;
	dx1=x2-x1;
	dy1=y2-y1;
	dx2=x4-x3;
	dy2=y4-y3;
	if(abs(dx1)>abs(dy1))s1=abs(dx1);
	 else s1=abs(dy1);
	if(abs(dx2)>abs(dy2))s2=abs(dx2);
	 else s2=abs(dy2);
	if(s1<s2)s1=s2;
	if(s1!=0)
	 {
		xi1=dx1/s1;
		yi1=dy1/s1;
		xi2=dx2/s1;
		yi2=dy2/s1;
		sori=(float)*(source+1)/(float)(s1);
	 }
	sor=0;
	putpixel2(x_1=x1,y_1=y1,*(source+3));
	x_2=x3;y_2=y3;
	for(k1=0;k1<s1;k1++,x_1+=xi1,y_1+=yi1,x_2+=xi2,y_2+=yi2,sor+=sori)
	 {
		dx=x_2-x_1;
		dy=y_2-y_1;
		if(abs(dx)>abs(dy))s=abs(dx);
		 else s=abs(dy);
		if(s!=0)
		 {
			xi=dx/s;
			yi=dy/s;
			oszi=(float)(*source)/(float)(s);
		 }
		t=(int)(sor)*(*source)+2;
		osz=0;
		putpixel2(x=x_1,y=y_1,*(source+t));
		for(k=0;k<=s;k++,x+=xi,y+=yi,osz+=oszi)
		 {
			putpixel2(x,y,*(source+t+(int)(osz)));
			if((int)(y+yi)>(int)(y))putpixel2(x,y+1,*(source+t+(int)(osz)));
		 }
	 }
 }

void szscircle(int kozepx,int kozepy,float sugar,float sz,unsigned char *source)
 {
	float piy,py=0,e=sugar/180,i;
	signed int y;
	piy=(*(source+1))/(180/e);
	for(i=1;i<180;i+=e,py+=piy)
	 {
		y=-sugar*mcos(i);
		sline(kozepx+(-sugar*msin(i))*mcos(sz)-y*msin(sz),kozepy+y*mcos(sz)+(-sugar*msin(i))*msin(sz),kozepx+(sugar*msin(i))*mcos(sz)-y*msin(sz),kozepy+y*mcos(sz)+(sugar*msin(i))*msin(sz),source+*source*(int)(py),*source);
	 }
 }

void szselipse(int kozepx,int kozepy,float sugarx,float sugary,float sz,unsigned char *source)
 {
	float pix,piy,py=0,px;
	int j,i,y,x1,y1;
	unsigned int col;
	piy=(*(source+1))/((180/sugary)*sugary);
	for(i=1;i<180;i++,py+=piy)
	 {
		pix=(*(source))/(sugarx*msin(i)*2+1);
		px=2;
		y=-sugary*mcos(i);
		for(j=-sugarx*msin(i);j<sugarx*msin(i);j++,px+=pix)
		 {
			y1=y*mcos(sz)+j*msin(sz);
			x1=j*mcos(sz)-y*msin(sz);
			col=(int)(py)**(source)+(int)(px);
			putpixel2(kozepx+x1,kozepy+y1,*(source+col));
			putpixel2(kozepx+x1,kozepy+y1+1,*(source+col));
			putpixel2(kozepx+x1+1,kozepy+y1,*(source+col));
		 }
	 }
 }

void sline(signed int x1o,signed int y1o,signed int x2o,signed int y2o,unsigned char far *source,unsigned char h)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	float k=0,ki;
	if((x1o<0 && x2o<0)||(x1o>319 && x2o>319))return;
	if((y1o<0 && y2o<0)||(y1o>199 && y2o>199))return;
	if(x1o==x2o && y1o==y2o)return;
	if(x1<0)
	 {
		x1=0;
		y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>319)
	 {
		x1=319;
		if(x1o!=x2o)y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>319)
	 {
		x2=319;
		if(x2o!=x1o)y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>199)
	 {
		y1=199;
		x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>199)
	 {
		y2=199;
		x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if((x1<0 && x2<0)||(x1>319 && x2>319))return;
	if((y1<0 && y2<0)||(y1>199 && y2>199))return;
	x1++;
	x2++;
	y1++;
	y2++;
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	ki=(float)h/(abs(x2o-x1o)+abs(y2o-y1o));
	k=ki*(abs(abs(y1o-y1)+abs(abs(x1o-x1))));
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1++;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	mov bx,p
	finit
	fld ki
	fld k
	mov dx,ds
	lds si,source
	inc si
	mov t,si
	fiadd t
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	jmp pixel
	}
 nagyobb:
	asm {
	fadd st,st(1)
	push ds
	mov ds,dx
	fist t
	mov si,t
	pop ds
	mov al,ds:[si]
	mov es:[di],al
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	fadd st,st(1)
	push ds
	mov ds,dx
	fist t
	mov si,t
	pop ds
	mov al,ds:[si]
	mov es:[di],al
	add di,xi
	loop ciklus
	mov ds,dx
	}
 }

void clearpot(unsigned char color)
 {
	int nr=potsize/2;
	asm {
	 les di,potscreen
	 mov cx,nr
	 mov al,color
	 mov ah,color
	 rep stosw
	}
 }

void copypottoscreen()
 {
	int nr=potsize/4;
	asm {
	 push ds
	 mov cx,nr
	 xor di,di
	 mov ax,0xa000
	 mov es,ax
	 lds si,potscreen
	 db 66h
	 rep movsw
	 pop ds
	}
 }

void putpixel2(int x,int y,unsigned char color)
 {
	asm {
	 mov ax,x
	 mov dx,y
	 cmp ax,0
	 jng vege
	 cmp dx,0
	 jng vege
	 cmp ax,319
	 jg vege
	 cmp dx,200
	 jg vege
	 les di,potscreen
	 mov bx,dx
	 shl dx,8
	 shl bx,6
	 add dx,bx
	 add di,dx
	 add di,ax
	 mov al,color
	 mov es:[di],al
	}
 vege:
 }

unsigned char getpixel2(int x,int y)
 {
	unsigned char visz=-0;
	asm {
	 cmp x,0
	 jng vege
	 cmp y,0
	 jng vege
	 cmp x,319
	 jg vege
	 cmp y,200
	 jg vege
	 les di,potscreen
	 mov ax,x
	 mov dx,y
	 mov bx,dx
	 shl dx,8
	 shl bx,6
	 add dx,bx
	 add di,dx
	 add di,ax
	 mov al,es:[di]
	 mov visz,al
	}
 vege:
	return(visz);
 }

void initpot()
 {potscreen=(unsigned char far *)malloc(potsize);}

void orveny(int kozepx,int kozepy,float sugar,float sz)
 {
	int i,j,szin;
	float ksz,szi;
	unsigned char a[100][100];
	szi=sz/sugar;
	ksz=szi;
	asm {
	mov ax,ds;
	mov es,ax
	mov di,OFFSET(a)
	sub di,32
	mov cx,10000
	mov ax,255
	rep stosb
	}
	for(j=sugar;j>0;j--,ksz+=szi)
	 for(i=0;i<360;i++)
		{
		 szin=getpixel2(kozepx+j*msin(i),kozepy-j*mcos(i));
		 a[25-j*mcos((i+ksz))][25+j*msin((i+ksz))]=szin;
		}
	for(i=0;i<sugar*2;i++)
	 for(j=0;j<sugar*2;j++)
		if(a[i][j]!=255)putpixel2(kozepx-sugar-4+j,kozepy-sugar-4+i,a[i][j]);
 }

void line2(signed int x1o,signed int y1o,signed int x2o,signed int y2o,unsigned char col)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	if((x1o<0 && x2o<0)||(x1o>319 && x2o>319))return;
	if((y1o<0 && y2o<0)||(y1o>199 && y2o>199))return;
	if(x1<0)
	 {
		x1=0;
		if(x2o!=x1o)y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			if(y2o!=y1o)x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			if(y2o!=y1o)x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>319)
	 {
		x1=319;
		if(x1o!=x2o)y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			if(y2o!=y1o)x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			if(y2o!=y1o)x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		if(x2o!=x1o)y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			if(y2o!=y1o)x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			if(y2o!=y1o)x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>319)
	 {
		x2=319;
		if(x2o!=x1o)y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			if(y2o!=y1o)x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			if(y2o!=y1o)x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		if(y2o!=y1o)x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>199)
	 {
		y1=199;
		if(y2o!=y1o)x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		if(y2o!=y1o)x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>199)
	 {
		y2=199;
		if(y2o!=y1o)x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if((x1<0 && x2<0)||(x1>319 && x2>319))return;
	if((y1<0 && y2<0)||(y1>199 && y2>199))return;
	x1++;
	x2++;
	y1++;
	y2++;
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1++;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	add cx,1
	mov al,col
	mov bx,p
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	jmp pixel
	}
 nagyobb:
	asm {
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	mov es:[di],al
	add di,xi
	loop ciklus
	}
 }

void fatline(signed int x1o,signed int y1o,signed int x2o,signed int y2o,unsigned char col)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	if((x1o<0 && x2o<0)||(x1o>319 && x2o>319))return;
	if((y1o<0 && y2o<0)||(y1o>199 && y2o>199))return;
	if(x1<0)
	 {
		x1=0;
		y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>319)
	 {
		x1=319;
		if(x1o!=x2o)y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>319)
	 {
		x2=319;
		if(x2o!=x1o)y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>199)
	 {
		y1=199;
		x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>199)
	 {
		y2=199;
		x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if((x1<0 && x2<0)||(x1>319 && x2>319))return;
	if((y1<0 && y2<0)||(y1>199 && y2>199))return;
	x1++;
	x2++;
	y1++;
	y2++;
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1++;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	mov al,col
	mov bx,p
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	jmp pixel
	}
 nagyobb:
	asm {
	mov es:[di],al
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	mov es:[di],al
	add di,xi
	loop ciklus
	}
 }

void tputpixel(int x,int y)
 {
	asm {
	 cmp x,0
	 jng vege
	 cmp y,0
	 jng vege
	 cmp x,319
	 jg vege
	 cmp y,200
	 jg vege
	 les di,potscreen
	 mov ax,x
	 mov dx,y
	 mov bx,dx
	 shl dx,8
	 shl bx,6
	 add dx,bx
	 add di,dx
	 add di,ax
	 mov ah,127
	 mov al,es:[di]
	 cmp ah,al
	 jna vege
	 add al,ah
	 mov es:[di],al
	}
 vege:
 }

void tline(signed int x1o,signed int y1o,signed int x2o,signed int y2o)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	if((x1o<0 && x2o<0)||(x1o>319 && x2o>319))return;
	if((y1o<0 && y2o<0)||(y1o>199 && y2o>199))return;
	if(x1<0)
	 {
		x1=0;
		y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>319)
	 {
		x1=319;
		if(x1o!=x2o)y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>319)
	 {
		x2=319;
		if(x2o!=x1o)y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>199)
	 {
		y1=199;
		x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>199)
	 {
		y2=199;
		x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if((x1<0 && x2<0)||(x1>319 && x2>319))return;
	if((y1<0 && y2<0)||(y1>199 && y2>199))return;
	x1++;
	x2++;
	y1++;
	y2++;
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1++;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	mov bx,p
	mov ah,127
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	jmp pixel
	}
 nagyobb:
	asm {
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	mov al,es:[di]
	cmp ah,al
	jna maratlatszo
	add al,ah
	mov es:[di],al
	}
 maratlatszo:
	asm {
	add di,xi
	loop ciklus
	}
 }

void inittransparent(signed char r,signed char g,signed char b)
 {
	unsigned char or,og,ob,i;
	for(i=0;i<127;i++)
	 {
		getpal(i,&or,&og,&ob);
		if(r+or<=63 && r+or>=0)or+=r;
			else if(r+or<0)or=0;
				else if(r+or>63)or=63;
		if(g+og<=63 && g+og>=0)og+=g;
		 else if(g+og<0)og=0;
			else if(g+og>63)og=63;
		if(b+ob<=63 && b+ob>=0)ob+=b;
		 else if(b+ob<0)ob=0;
			else if(b+ob>63)ob=63;
		setpal(i+127,or,og,ob);
	 }
 }

void fadepixel(unsigned char i,signed char el)
 {
	unsigned char or,og,ob;
		getpal(i,&or,&og,&ob);
		if(el+or<=63 && el+or>=0)or+=el;
			else if(el+or<0)or=0;
				else if(el+or>63)or=63;
		if(el+og<=63 && el+og>=0)og+=el;
		 else if(el+og<0)og=0;
			else if(el+og>63)og=63;
		if(el+ob<=63 && el+ob>=0)ob+=el;
		 else if(el+ob<0)ob=0;
			else if(el+ob>63)ob=63;
		setpal(i,or,og,ob);
 }

 void savepal()
	{
	 unsigned char i;
	 for(i=0;i<255;i++)
		{
		 getpal(i,&pal[i][0],&pal[i][1],&pal[i][2]);
		}
	}

 void loadpal()
	{
	 unsigned char i;
	 for(i=0;i<255;i++)
		{
		 setpal(i,pal[i][0],pal[i][1],pal[i][2]);
		}
	}

void htline(int kx,int vx,int y)
 {
	int kx2=kx,vx2=vx,dx1;
	if(y<0|| y>200)return;
	if(kx==vx)return;
	if(kx<0)kx2=0;
	 else if(kx>320)kx2=320;
	if(vx<0)vx2=0;
	 else if(vx>320)vx2=320;
	dx1=abs(kx2-vx2);
	if(kx2>vx2)kx2=vx2;
	asm {
	les di,potscreen
	mov dx,y
	mov bx,dx
	shl dx,8
	shl bx,6
	add dx,bx
	add di,dx
	add di,kx2
	mov cx,dx1
	mov ah,127
	}
 ciklus:
	asm {
	mov al,es:[di]
	cmp ah,al
	jna nopixel
	add al,ah
	}
 nopixel:
	asm {
	stosb
	loop ciklus
	}
 }

void tcircle(int kozepx,int kozepy,float sugar)
 {
	float i,e=sugar/180;
	for(i=0;i<90;i+=e)
	 {
		tputpixel(kozepx+sugar*msin(i),kozepy-sugar*mcos(i));
		tputpixel(kozepx-sugar*msin(i),kozepy-sugar*mcos(i));
		tputpixel(kozepx+sugar*msin(i),kozepy+sugar*mcos(i));
		tputpixel(kozepx-sugar*msin(i),kozepy+sugar*mcos(i));
	 }
 }

void telipse(int kozepx,int kozepy,float sugarx,float sugary,float sz)
 {
	float i,e,x,y,x1,y1;
	if(sugarx>sugary)e=sugarx/360;
	 else e=sugary/360;
	for(i=1;i<360;i+=e)
	 {
		y1=(sugary*mcos(i))*mcos(sz)+(sugarx*msin(i))*msin(sz);
		x1=(sugarx*msin(i))*mcos(sz)-(sugary*mcos(i))*msin(sz);
		tputpixel(kozepx+x1,kozepy+y1);
	 }
 }

void ftcircle(int kozepx,int kozepy,float sugar)
 {
	float i,e=sugar/180;
	for(i=0;i<90;i+=e)
	 {
		htline(kozepx+sugar*msin(i),kozepx-sugar*msin(i),kozepy-sugar*mcos(i));
		htline(kozepx+sugar*msin(i),kozepx-sugar*msin(i),kozepy+sugar*mcos(i));
	 }
 }

void ftelipse(int kozepx,int kozepy,float sugarx,float sugary,float sz)
 {
	int j,i,y,x1,y1;
	for(i=1;i<180;i++)
	 {
		y=-sugary*mcos(i);
		for(j=-sugarx*msin(i);j<sugarx*msin(i);j++)
		 {
			y1=y*mcos(sz)+j*msin(sz);
			x1=j*mcos(sz)-y*msin(sz);
			tputpixel(kozepx+x1,kozepy+y1);
			tputpixel(kozepx+x1,kozepy+y1+1);
		 }
	 }
 }

void fill(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,unsigned char *source)
 {
	float xi1,yi1,x_1,y_1;
	float xi2,yi2,x_2,y_2;
	float s,si;
	int dx1,dy1,dx2,dy2;
	int s1,s2,k1;
	dx1=x2-x1;
	dy1=y2-y1;
	dx2=x4-x3;
	dy2=y4-y3;
	if(abs(dx1)>abs(dy1))s1=abs(dx1);
	 else s1=abs(dy1);
	if(abs(dx2)>abs(dy2))s2=abs(dx2);
	 else s2=abs(dy2);
	if(s1<s2)s1=s2;
	xi1=(float)dx1/s1;
	yi1=(float)dy1/s1;
	xi2=(float)dx2/s1;
	yi2=(float)dy2/s1;
	si=(float)*(source+1)/s1;
	s=0;
	x_1=x1;y_1=y1;x_2=x3;y_2=y3;
	for(k1=0;k1<s1;k1++,x_1+=xi1,y_1+=yi1,x_2+=xi2,y_2+=yi2,s+=si)
	 sline(x_1,y_1,x_2,y_2,source+(int)s**source-1,*source-2);
 }

void putgpi(int x,int y,unsigned char far * data)
 {
	asm {
	push ds
	les di,potscreen
	add di,x
	mov ax,y
	mov bx,320
	mul bx
	add di,ax
	lds si,data
	mov dl,ds:[si]
	mov ax,320
	sub ax,dx
	inc si
	xor ch,ch
	mov cl,ds:[si]
	inc si
	}
 ujsor:
	asm {
	mov dh,cl
	mov cl,dl
	rep movsb
	add di,ax
	mov cl,dh
	loop ujsor
	pop ds
	}
 }

void putpic(unsigned char far *data,int x,int y,unsigned char dx1,unsigned char dy,unsigned char sh)
 {
/*milyen hosszu igazabol a kep*/
	unsigned char sh1=sh-dx1;
	asm {
	push ds
	les di,potscreen
	add di,x
	mov ax,y
	mov bx,320
	mul bx
	add di,ax
	xor dh,dh
	xor bh,bh
	mov bl,sh1
	mov dl,dx1
	mov ax,320
	sub ax,dx
	xor ch,ch
	mov cl,dy
	lds si,data
	}
 ujsor:
	asm {
	push cx
	mov cl,dl
	rep movsb
	add di,ax
	add si,bx
	pop cx
	loop ujsor
	pop ds
	}
 }

void safeputgpi(int x,int y,unsigned char far *source)
 {
	int x2=x,y2=y,bx=0,by=0,dx=*source,dy=*(source+1);
	if(y<0)
	 {
		y2=0;
		by=-y*(*source);
		dy+=y;
	 }
	if(y+dy>200)dy=*(source+1)-(y+dy-200);
	if(x<0)
	 {
		x2=0;
		bx=-x;
		dx+=x;
	 }
	if(x+dx>320)dx=*(source)-(x+dx-320);
	putpic(source+bx+by+2,x2,y2,dx,dy,*source);
 }

void hsline(int x1,int x2,int y,unsigned char far *source,unsigned char h)
 {
	int nx1=x1,nx2=x2,xi,dx1,t;
	float k,ki;
	if(y<0 || y>200)return;
	if(x1<0)nx1=0;
	 else if(x1>320)nx1=320;
	if(x2<0)nx2=0;
	 else if(x2>320)nx2=320;
	dx1=abs(nx2-nx1);
	if(nx1<nx2)xi=1;
	 else xi=-1;
	ki=(float)h/abs(x2-x1);
	k=ki*(abs(abs(x2-x1)-dx1));
	asm {
	 les di,potscreen
	 mov ax,320
	 mov bx,y
	 mul bx
	 add di,ax
	 add di,nx1
	 mov cx,dx1
	 finit
	 fld ki
	 fld k
	 mov bx,ds
	 lds si,source
	 mov dx,ds
	 mov t,si
	 fiadd t
	}
 ciklus:
	asm {
	 fadd st,st(1)
	 mov ds,bx
	 fist t
	 mov si,t
	 mov ds,dx
	 mov al,ds:[si]
	 mov es:[di],al
	 add di,xi
	 loop ciklus
	 mov ds,bx
	}
 }

void fitgpi(int x1o,int y1o,int x2o,int y2o,unsigned unsigned char far *source)
 {
	int i,ky=y1o,vy=y2o,ii;
	float s,si;
	if(y1o<0)ky=0;
	 else if(y1o>200)ky=200;
	if(y2o<0)vy=0;
	 else if(y2o>200)vy=200;
	if(y1o<y2o)ii=1;
	 else ii=-1;
	si=(float)*(source+1)/abs(y2o-y1o);
	s=si*(abs(abs(y2o-y1o)-abs(vy-ky)));
	for(i=ky;i!=vy;i+=ii,s+=si)
	 hsline(x1o,x2o,i,source+(int)(s)**source+2,*source-1);
 }

void circle2(int x,int y,int sugar,unsigned char color)
 {
	float i,e=(float)sugar/180;
	for(i=0;i<90;i+=e)
	 {
		putpixel2(x+sugar*msin(i),y-sugar*mcos(i),color);
		putpixel2(x-sugar*msin(i),y-sugar*mcos(i),color);
		putpixel2(x+sugar*msin(i),y+sugar*mcos(i),color);
		putpixel2(x-sugar*msin(i),y+sugar*mcos(i),color);
	 }
 }

void hline(int x1,int x2,int y,unsigned char color)
 {
	int nx1=x1,nx2=x2,dx1;
	if(y<0 || y>200)return;
	if(x1<0)nx1=0;
	 else if(x1>320)nx1=320;
	if(x2<0)nx2=0;
	 else if(x2>320)nx2=320;
	dx1=abs(nx2-nx1);
	if(nx2<nx1)nx1=nx2;
	asm {
	 les di,potscreen
	 mov ax,320
	 mov bx,y
	 mul bx
	 add di,ax
	 add di,nx1
	 mov cx,dx1
	 mov al,color
	 rep stosb
	}
 }

void fcircle2(int x,int y,int sugar,unsigned char color)
 {
	float i,e=(float)sugar/180;
	for(i=0;i<90;i+=e)
	 {
		hline(x-sugar*msin(i),x+sugar*msin(i),y-sugar*mcos(i),color);
		hline(x-sugar*msin(i),x+sugar*msin(i),y+sugar*mcos(i),color);
	 }
 }

void szelipse(int kozepx,int kozepy,int sugarx,int sugary,float sz,unsigned char color)
 {
	float i,e,x,y,x1,y1;
	if(sugarx>sugary)e=(float)sugarx/360;
	 else e=(float)sugary/360;
	for(i=1;i<180;i+=e)
	 {
		y1=(sugary*mcos(i))*mcos(sz)+(sugarx*msin(i))*msin(sz);
		x1=(sugarx*msin(i))*mcos(sz)-(sugary*mcos(i))*msin(sz);
		putpixel2(kozepx+x1,kozepy+y1,color);
		putpixel2(kozepx-x1,kozepy-y1,color);
	 }
 }

void fszelipse(int kozepx,int kozepy,int sugarx,int sugary,float sz,unsigned char color)
 {
	int j,i,y,x1,y1;
	for(i=1;i<180;i++)
	 {
		y=-sugary*mcos(i);
		for(j=-sugarx*msin(i);j<sugarx*msin(i);j++)
		 {
			y1=y*mcos(sz)+j*msin(sz);
			x1=j*mcos(sz)-y*msin(sz);
			putpixel2(kozepx+x1,kozepy+y1,color);
			putpixel2(kozepx+x1,kozepy+y1+1,color);
		 }
	 }
 }

void onlyfill(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,unsigned char *source,unsigned char noc)
 {
	float xi1,yi1,x_1,y_1;
	float xi2,yi2,x_2,y_2;
	float s,si;
	int dx1,dy1,dx2,dy2;
	int s1,s2,k1;
	dx1=x2-x1;
	dy1=y2-y1;
	dx2=x4-x3;
	dy2=y4-y3;
	if(abs(dx1)>abs(dy1))s1=abs(dx1);
	 else s1=abs(dy1);
	if(abs(dx2)>abs(dy2))s2=abs(dx2);
	 else s2=abs(dy2);
	if(s1<s2)s1=s2;
	xi1=(float)dx1/s1;
	yi1=(float)dy1/s1;
	xi2=(float)dx2/s1;
	yi2=(float)dy2/s1;
	si=(float)*(source+1)/s1;
	s=0;
	x_1=x1;y_1=y1;x_2=x3;y_2=y3;
	for(k1=0;k1<s1;k1++,x_1+=xi1,y_1+=yi1,x_2+=xi2,y_2+=yi2,s+=si)
	 nsline(x_1,y_1,x_2,y_2,source+(int)s**source,*source+1,noc);
 }


void onlysline(signed int x1o,signed int y1o,signed int x2o,signed int y2o,unsigned char far *source,int h,unsigned char noc)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	float k=0,ki;
	if((x1o<0 && x2o<0)||(x1o>320 && x2o>320))return;
	if((y1o<0 && y2o<0)||(y1o>200 && y2o>200))return;
	if(x1<0)
	 {
		x1=0;
		y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y1>200)
		 {
			y1=200;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>320)
	 {
		x1=320;
		y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y1>200)
		 {
			y1=200;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y2>200)
		 {
			y2=200;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>320)
	 {
		x2=320;
		y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y2>200)
		 {
			y2=200;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>200)
	 {
		y1=200;
		x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>200)
	 {
		y2=200;
		x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y1==y2 && y1==0)
	 {
		y1=1;y2=1;
	 }
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	ki=(float)h/(abs(x2o-x1o)+abs(y2o-y1o));
	k=ki*(abs(abs(x2o-x1o)-dx1)+abs(abs(y2o-y1o)-dy));
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1--;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	mov bx,p
	finit
	fld ki
	fld k
	mov dx,ds
	lds si,source
	inc si
	mov t,si
	fiadd t
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	jmp pixel
	}
 nagyobb:
	asm {
	fadd st,st(1)
	push ds
	mov ds,dx
	fist t
	mov si,t
	pop ds
	mov al,ds:[si]
	cmp al,noc
	jne nop1
	mov es:[di],al
	}
 nop1:
	asm {
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	fadd st,st(1)
	push ds
	mov ds,dx
	fist t
	mov si,t
	pop ds
	mov al,ds:[si]
	cmp al,noc
	jne nop2
	mov es:[di],al
	}
 nop2:
	asm {
	add di,xi
	loop ciklus
	mov ds,dx
	}
 }

void nfill(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,unsigned char *source,unsigned char noc)
 {
	float xi1,yi1,x_1,y_1;
	float xi2,yi2,x_2,y_2;
	float s,si;
	int dx1,dy1,dx2,dy2;
	int s1,s2,k1;
	dx1=x2-x1;
	dy1=y2-y1;
	dx2=x4-x3;
	dy2=y4-y3;
	if(abs(dx1)>abs(dy1))s1=abs(dx1);
	 else s1=abs(dy1);
	if(abs(dx2)>abs(dy2))s2=abs(dx2);
	 else s2=abs(dy2);
	if(s1<s2)s1=s2;
	xi1=(float)dx1/s1;
	yi1=(float)dy1/s1;
	xi2=(float)dx2/s1;
	yi2=(float)dy2/s1;
	si=(float)*(source+1)/s1;
	s=0;
	x_1=x1;y_1=y1;x_2=x3;y_2=y3;
	for(k1=0;k1<s1;k1++,x_1+=xi1,y_1+=yi1,x_2+=xi2,y_2+=yi2,s+=si)
	 nsline(x_1,y_1,x_2,y_2,source+(int)s**source,*source+1,noc);
 }


void nsline(signed int x1o,signed int y1o,signed int x2o,signed int y2o,unsigned char far *source,int h,unsigned char noc)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	float k=0,ki;
	if((x1o<0 && x2o<0)||(x1o>320 && x2o>320))return;
	if((y1o<0 && y2o<0)||(y1o>200 && y2o>200))return;
	if(x1<0)
	 {
		x1=0;
		y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y1>200)
		 {
			y1=200;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>320)
	 {
		x1=320;
		y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y1>200)
		 {
			y1=200;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y2>200)
		 {
			y2=200;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>320)
	 {
		x2=320;
		y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		if(y2>200)
		 {
			y2=200;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>200)
	 {
		y1=200;
		x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>200)
	 {
		y2=200;
		x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y1==y2 && y1==0)
	 {
		y1=1;y2=1;
	 }
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	ki=(float)h/(abs(x2o-x1o)+abs(y2o-y1o));
	k=ki*(abs(abs(x2o-x1o)-dx1)+abs(abs(y2o-y1o)-dy));
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1--;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	mov bx,p
	finit
	fld ki
	fld k
	mov dx,ds
	lds si,source
	inc si
	mov t,si
	fiadd t
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	jmp pixel
	}
 nagyobb:
	asm {
	fadd st,st(1)
	push ds
	mov ds,dx
	fist t
	mov si,t
	pop ds
	mov al,ds:[si]
	cmp al,noc
	je nop1
	mov es:[di],al
	}
 nop1:
	asm {
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	fadd st,st(1)
	push ds
	mov ds,dx
	fist t
	mov si,t
	pop ds
	mov al,ds:[si]
	cmp al,noc
	je nop2
	mov es:[di],al
	}
 nop2:
	asm {
	add di,xi
	loop ciklus
	mov ds,dx
	}
 }

void savegpi(int x1,int y1,unsigned char dx,unsigned char dy,unsigned char * nev)
 {
	int i,j,t1,f=open(nev,O_TRUNC | O_CREAT | O_WRONLY | O_DENYNONE);
	unsigned unsigned char t;
	if(f==-1)return;
	t=dx;
	_write(f,&t,1);
	t=dy;
	_write(f,&t,1);
	for(j=y1+1;j<=y1+dy+1;j++)
	 {
		t1=(j-1)*320;
		for(i=x1;i<=x1+dx-1;i++)
		 {
			t=*(vgascreen+t1+i);
			_write(f,&t,1);
		 }
	 }
	close(f);
 }

unsigned char far * savepic(int x1,int y1,unsigned char dx,unsigned char dy)
 {
	int i,j,t1,i1,j1=0;
	unsigned char t;
	unsigned char far *source;
	source=(unsigned char *)malloc(dx*dy+2);
	if(source==NULL)return(source);
	*source=dx;
	*(source+1)=dy;
	for(j=y1+1;j<=y1+dy+1;j++)
	 {
		t1=(j-1)*320;
		i1=0;
		for(i=x1;i<=x1+dx-1;i++)
		 {
			i1++;
			t=*(vgascreen+t1+i);
			*(vgascreen+t1+i)=t;
			*(source+j1+i1+2)=t;
		 }
		j1+=dx;
	 }
	return(source);
 }

void bar2(int x1,int y1,int x2,int y2,unsigned char color)
 {
	unsigned char dx1=abs(x1-x2),dy=abs(y2-y1);
	int x,y;
	if(x1<x2)x=x1;
	 else x=x2;
	if(y1<y2)y=y1;
	 else y=y2;
	if(x<0)x=0;
	if(y<0)y=0;
	if(x+dx1>320)dx1=320-x;
	if(y+dy>200)dy=320-y;
	asm {
	push ds
	les di,potscreen
	add di,x
	mov ax,y
	mov bx,320
	mul bx
	add di,ax
	xor dh,dh
	mov dl,dx1
	mov bx,320
	sub bx,dx
	xor ch,ch
	mov cl,dy
	xor ah,ah
  mov al,color
	}
 ujsor:
	asm {
	push cx
	mov cl,dl
	rep stosb
	add di,bx
	pop cx
	loop ujsor
	pop ds
	}
 }

void nsafeputgpi(int x,int y,unsigned char far *source,unsigned char noc)
 {
	int x2=x,y2=y,bx=0,by=0,dx=*source,dy=*(source+1);
	if(y<0)
	 {
		y2=0;
		by=-y*(*source);
		dy+=y;
	 }
	if(y+dy>200)dy=*(source+1)-(y+dy-200);
	if(x<0)
	 {
		x2=0;
		bx=-x;
		dx+=x;
	 }
	if(x+dx>320)dx=*(source)-(x+dx-320);
	nputpic(source+bx+by+2,x2,y2,dx,dy,*source,noc);
 }

void nputpic(unsigned char far *data,int x,int y,unsigned char dx1,unsigned char dy,unsigned char sh,unsigned char noc)
 {
/*milyen hosszu igazabol a kep*/
	unsigned char sh1=sh-dx1;
	asm {
	push ds
	les di,potscreen
	add di,x
	mov ax,y
	mov bx,320
	mul bx
	add di,ax
	xor dh,dh
	xor bh,bh
	mov bl,sh1
	mov dl,dx1
	mov ax,320
	sub ax,dx
	xor ch,ch
	mov cl,dy
	lds si,data
	}
 ujsor:
	asm {
	push cx
	mov cl,dl
	}
 ciklus:
	asm {
	mov dh,ds:[si]
	cmp dh,noc
	je nopixel
	mov es:[di],dh
	}
 nopixel:
	asm {
	inc si
	inc di
	loop ciklus
	}
	asm {
	add di,ax
	add si,bx
	pop cx
	loop ujsor
	pop ds
	}
 }

void onlysafeputgpi(int x,int y,unsigned char far *source,unsigned char noc)
 {
	int x2=x,y2=y,bx=0,by=0,dx=*source,dy=*(source+1);
	if(y<0)
	 {
		y2=0;
		by=-y*(*source);
		dy+=y;
	 }
	if(y+dy>200)dy=*(source+1)-(y+dy-200);
	if(x<0)
	 {
		x2=0;
		bx=-x;
		dx+=x;
	 }
	if(x+dx>320)dx=*(source)-(x+dx-320);
	onlyputpic(source+bx+by+2,x2,y2,dx,dy,*source,noc);
 }

void onlyputpic(unsigned char far *data,int x,int y,unsigned char dx1,unsigned char dy,unsigned char sh,unsigned char noc)
 {
/*milyen hosszu igazabol a kep*/
	unsigned char sh1=sh-dx1;
	asm {
	push ds
	les di,potscreen
	add di,x
	mov ax,y
	mov bx,320
	mul bx
	add di,ax
	xor dh,dh
	xor bh,bh
	mov bl,sh1
	mov dl,dx1
	mov ax,320
	sub ax,dx
	xor ch,ch
	mov cl,dy
	lds si,data
	}
 ujsor:
	asm {
	push cx
	mov cl,dl
	}
 ciklus:
	asm {
	mov dh,ds:[si]
	cmp dh,noc
	jne nopixel
	mov es:[di],dh
	}
 nopixel:
	asm {
	inc si
	inc di
	loop ciklus
	}
	asm {
	add di,ax
	add si,bx
	pop cx
	loop ujsor
	pop ds
	}
 }

void nfitgpi(int x1o,int y1o,int x2o,int y2o,unsigned char far *source,unsigned char noc)
 {
	int i,ky=y1o,vy=y2o,ii;
	float s,si;
	if(y1o<0)ky=0;
	 else if(y1o>200)ky=200;
	if(y2o<0)vy=0;
	 else if(y2o>200)vy=200;
	if(y1o<y2o)ii=1;
	 else ii=-1;
	si=(float)*(source+1)/abs(y2o-y1o);
	s=si*(abs(abs(y2o-y1o)-abs(vy-ky)));
	for(i=ky;i!=vy;i+=ii,s+=si)
	 nhsline(x1o,x2o,i,source+(int)(s)**source+2,*source-1,noc);
 }

void nhsline(int x1,int x2,int y,unsigned char far *source,unsigned char h,unsigned char noc)
 {
	int nx1=x1,nx2=x2,xi,dx1,t;
	float k,ki;
	if(y<0 || y>200)return;
	if(x1<0)nx1=0;
	 else if(x1>320)nx1=320;
	if(x2<0)nx2=0;
	 else if(x2>320)nx2=320;
	dx1=abs(nx2-nx1);
	if(nx1<nx2)xi=1;
	 else xi=-1;
	ki=(float)h/abs(x2-x1);
	k=ki*(abs(abs(x2-x1)-dx1));
	asm {
	 les di,potscreen
	 mov ax,320
	 mov bx,y
	 mul bx
	 add di,ax
	 add di,nx1
	 mov cx,dx1
	 finit
	 fld ki
	 fld k
	 mov bx,ds
	 lds si,source
	 mov dx,ds
	 mov t,si
	 fiadd t
	 mov ah,noc
	}
 ciklus:
	asm {
	 fadd st,st(1)
	 mov ds,bx
	 fist t
	 mov si,t
	 mov ds,dx
	 mov al,ds:[si]
	 cmp ah,al
	 je nopixel
	 mov es:[di],al
	 }
 nopixel:
	 asm {
	 add di,xi
	 loop ciklus
	 mov ds,bx
	}
 }

void onlyfitgpi(int x1o,int y1o,int x2o,int y2o,unsigned char far *source,unsigned char noc)
 {
	int i,ky=y1o,vy=y2o,ii;
	float s,si;
	if(y1o<0)ky=0;
	 else if(y1o>200)ky=200;
	if(y2o<0)vy=0;
	 else if(y2o>200)vy=200;
	if(y1o<y2o)ii=1;
	 else ii=-1;
	si=(float)*(source+1)/abs(y2o-y1o);
	s=si*(abs(abs(y2o-y1o)-abs(vy-ky)));
	for(i=ky;i!=vy;i+=ii,s+=si)
	 onlyhsline(x1o,x2o,i,source+(int)(s)**source+2,*source-1,noc);
 }

void onlyhsline(int x1,int x2,int y,unsigned char far *source,unsigned char h,unsigned char noc)
 {
	int nx1=x1,nx2=x2,xi,dx1,t;
	float k,ki;
	if(y<0 || y>200)return;
	if(x1<0)nx1=0;
	 else if(x1>320)nx1=320;
	if(x2<0)nx2=0;
	 else if(x2>320)nx2=320;
	dx1=abs(nx2-nx1);
	if(nx1<nx2)xi=1;
	 else xi=-1;
	ki=(float)h/abs(x2-x1);
	k=ki*(abs(abs(x2-x1)-dx1));
	asm {
	 les di,potscreen
	 mov ax,320
	 mov bx,y
	 mul bx
	 add di,ax
	 add di,nx1
	 mov cx,dx1
	 finit
	 fld ki
	 fld k
	 mov bx,ds
	 lds si,source
	 mov dx,ds
	 mov t,si
	 fiadd t
	 mov ah,noc
	}
 ciklus:
	asm {
	 fadd st,st(1)
	 mov ds,bx
	 fist t
	 mov si,t
	 mov ds,dx
	 mov al,ds:[si]
	 cmp ah,al
	 jne nopixel
	 mov es:[di],al
	 }
 nopixel:
	 asm {
	 add di,xi
	 loop ciklus
	 mov ds,bx
	}
 }

void szgpi(int x1o,int y1o,int x2o,int y2o,int x3o,int y3o,int x4o,int y4o,unsigned char *source,float sz)
 {
	int x1,x2,x3,x4,y1,y2,y3,y4,minx=x1o,maxx=x1o,miny=y1o,maxy=y1o,kx,ky,t;
	float xi1,yi1,x_1,y_1;
	float xi2,yi2,x_2,y_2;
	float s,si;
	int dx1,dy1,dx2,dy2;
	int s1,s2,k1;
	if(x2o<minx)minx=x2o;
	if(x3o<minx)minx=x3o;
	if(x4o<minx)minx=x4o;
	if(x2o>maxx)maxx=x2o;
	if(x3o>maxx)maxx=x3o;
	if(x4o>maxx)maxx=x4o;
	if(y2o<miny)miny=y2o;
	if(y3o<miny)miny=y3o;
	if(y4o<miny)miny=y4o;
	if(y2o>maxy)maxy=y2o;
	if(y3o>maxy)maxy=y3o;
	if(y4o>maxy)maxy=y4o;
	kx=(minx+maxx)/2;
	ky=(miny+maxy)/2;
	x1=kx-((kx-x1o)*mcos(sz)-(ky-y1o)*msin(sz));
	y1=ky-((kx-x1o)*msin(sz)+(ky-y1o)*mcos(sz));
	x2=kx-((kx-x2o)*mcos(sz)-(ky-y2o)*msin(sz));
	y2=ky-((kx-x2o)*msin(sz)+(ky-y2o)*mcos(sz));
	x3=kx-((kx-x3o)*mcos(sz)-(ky-y3o)*msin(sz));
	y3=ky-((kx-x3o)*msin(sz)+(ky-y3o)*mcos(sz));
	x4=kx-((kx-x4o)*mcos(sz)-(ky-y4o)*msin(sz));
	y4=ky-((kx-x4o)*msin(sz)+(ky-y4o)*mcos(sz));
	dx1=x2-x1;
	dy1=y2-y1;
	dx2=x4-x3;
	dy2=y4-y3;
	if(abs(dx1)>abs(dy1))s1=abs(dx1);
	 else s1=abs(dy1);
	if(abs(dx2)>abs(dy2))s2=abs(dx2);
	 else s2=abs(dy2);
	if(s1<s2)s1=s2;
	xi1=(float)dx1/s1;
	yi1=(float)dy1/s1;
	xi2=(float)dx2/s1;
	yi2=(float)dy2/s1;
	si=(float)*(source+1)/s1;
	s=0;
	x_1=x1;y_1=y1;x_2=x3;y_2=y3;
	for(k1=0;k1<s1;k1++,x_1+=xi1,y_1+=yi1,x_2+=xi2,y_2+=yi2,s+=si)
	 sline(x_1,y_1,x_2,y_2,source+(int)s**source+1,*source);
 }

void scircle(int x,int y,int s,unsigned char far *source)
 {
	int i;
	float k=0,ki;
	ki=(float)(*(source+1))/(s*2);
	for(i=-s+1;i<s;i++,k+=ki)
		hsline(x-sqrt(sqr(s)-sqr(i)),x+sqrt(sqr(s)-sqr(i)),y+i,source+(int)(k)**source,*source);
 }

void selipse(int kozepx,int kozepy,int sugarx,int sugary,unsigned char far *source)
 {
	float i,e,k=0,ki;
	int x=0,y=sugary*mcos(1);
	e=(float)sugary/360;
	ki=(float)(*(source+1))/(sugary*2);
	for(i=1;i<180;i+=e)
	 {
		x=sugarx*msin(i);
		if(y!=(int)(sugary*mcos(i)))
		 {
			k+=ki;
			y=sugary*mcos(i);
			hsline(kozepx-x,kozepx+x,kozepy-y,source+(int)(k)**source,*source);
		 }
	 }
 }

void tbar(int x1,int y1,int x2,int y2)
 {
	unsigned int dx1=abs(x1-x2),dy=abs(y2-y1);
	int x,y;
	if(x1<x2)x=x1;
	 else x=x2;
	if(y1<y2)y=y1;
	 else y=y2;
	if(x<0)x=0;
	if(y<0)y=0;
	if(x+dx1>320)dx1=320-x;
	if(y+dy>200)dy=320-y;
	asm {
	push ds
	les di,potscreen
	add di,x
	mov ax,y
	mov bx,320
	mul bx
	add di,ax
	mov dx,dx1
	mov bx,320
	sub bx,dx
	mov cx,dy
	mov ah,127
	}
 ujsor:
	asm {
	push cx
	mov cx,dx
	}
 ciklus:
	asm {
	mov al,es:[di]
	cmp ah,al
	jna nop
	add al,ah
	mov es:[di],al
	}
 nop:
	asm {
	inc di
	loop ciklus
	add di,bx
	pop cx
	loop ujsor
	pop ds
	}
 }

void tfill(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4)
 {
	float xi1,yi1,x_1,y_1;
	float xi2,yi2,x_2,y_2;
	int dx1,dy1,dx2,dy2;
	int s1,s2,k1;
	dx1=x2-x1;
	dy1=y2-y1;
	dx2=x4-x3;
	dy2=y4-y3;
	if(abs(dx1)>abs(dy1))s1=abs(dx1);
	 else s1=abs(dy1);
	if(abs(dx2)>abs(dy2))s2=abs(dx2);
	 else s2=abs(dy2);
	if(s1<s2)s1=s2;
	xi1=(float)dx1/s1;
	yi1=(float)dy1/s1;
	xi2=(float)dx2/s1;
	yi2=(float)dy2/s1;
	x_1=x1;y_1=y1;x_2=x3;y_2=y3;
	for(k1=0;k1<s1;k1++,x_1+=xi1,y_1+=yi1,x_2+=xi2,y_2+=yi2)
	 tline2(x_1,y_1,x_2,y_2);
 }

void tline2(signed int x1o,signed int y1o,signed int x2o,signed int y2o)
 {
	signed int dx1,dy,p,const_1,const_2,yi,xi;
	signed int t,x1=x1o,x2=x2o,y1=y1o,y2=y2o;
	if((x1o<0 && x2o<0)||(x1o>319 && x2o>319))return;
	if((y1o<0 && y2o<0)||(y1o>199 && y2o>199))return;
	if(x1<0)
	 {
		x1=0;
		y1=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	 else if(x1>319)
	 {
		x1=319;
		if(x1o!=x2o)y1=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y1<0)
		 {
			y1=0;
			x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y1>199)
		 {
			y1=199;
			x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(x2<0)
	 {
		x2=0;
		y2=(long)(-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	else if(x2>319)
	 {
		x2=319;
		if(x2o!=x1o)y2=(long)(320-x1o)*(y2o-y1o)/(x2o-x1o)+y1o;
		if(y2<0)
		 {
			y2=0;
			x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
		else if(y2>199)
		 {
			y2=199;
			x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
		 }
	 }
	if(y1<0)
	 {
		y1=0;
		x1=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y1>199)
	 {
		y1=199;
		x1=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if(y2<0)
	 {
		y2=0;
		x2=(long)(-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	 else if(y2>199)
	 {
		y2=199;
		x2=(long)(200-y1o)*(x2o-x1o)/(y2o-y1o)+x1o;
	 }
	if((x1<0 && x2<0)||(x1>319 && x2>319))return;
	if((y1<0 && y2<0)||(y1>199 && y2>199))return;
	x1++;
	x2++;
	y1++;
	y2++;
	dx1=abs(x2-x1);
	dy=abs(y2-y1);
	if(y1<y2)yi=320;
	 else if(y1>y2)yi=-320;
		else yi=0;
	if(x1<x2)xi=1;
	 else if(x1>x2)xi=-1;
		else xi=0;
	if(dx1<dy)
	 {
		t=dx1;dx1=dy;dy=t;
		t=xi;xi=yi;yi=t;
	 }
	dx1++;
	asm {
	mov ax,dy
	shl ax,2
	sub ax,dx1
	mov p,ax
	mov ax,dy
	shl ax,2
	mov const_1,ax
	mov bx,dx1
	shl bx,2
	sub ax,bx
	mov const_2,ax
	les di,potscreen
	mov ax,y1
	dec ax
	mov bx,320
	mul bx
	add ax,x1
	dec ax
	add di,ax
	mov cx,dx1
	mov bx,p
	mov ah,127
	}
 ciklus:
	asm {
	cmp bx,0
	jg nagyobb
	add bx,const_1
	mov al,es:[di+320]
	cmp ah,al
	jna maratlatszo
	add al,ah
	mov es:[di+320],al
	jmp pixel
	}
 nagyobb:
	asm {
	add di,yi
	add bx,const_2
	}
 pixel:
	asm {
	mov al,es:[di]
	cmp ah,al
	jna maratlatszo
	add al,ah
	mov es:[di],al
	}
 maratlatszo:
	asm {
	add di,xi
	loop ciklus
	}
 }
